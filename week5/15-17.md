# 5부 아키텍처 
## 15장 아키텍처란?
1. 개발 : 시스템 아키텍처는 개발팀들이 시스템을 쉽게 개발할 수 있도록 뒷받침해야한다.
2. 배포 : 배포 비용이 높을 수록 시스템의 유용성은 떨어진다. 따라서 단 한번에 쉽게 배포할 수 있도록 만드는데 목표를 두어야 한다. 
3. 운영 : 아키텍처가 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜 극적이다.
    - 하드웨어는 싸고 인력은 비싸다 : 운영을 방해하는 아키텍처가 개발/배포/유지보수를 방해하는 아키텍처보다는 비용이 덜든다. 
    - 그래도 좋은 아키텍처는 시스템을 운영하는데 필요한 요구도 알려준다. (개발자에게 시스템의 운영방시을 잘 나타내준다) 
    - 시스템 아키텍처는 유스케이스/기능/시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다. -> 시스템 이해 쉬워지고, 개발과 유지보수에 도움
4. 유지보수 : 소프트웨어 시스템에서 가장 비용이 많이 든다. 신중하게 아키텍처를 만들면 유지보수 비용을 크게 줄일 수 있다
    - 시스템을 컴포넌트로 분리하고 안정된 인터페이스를 두어 서로 격리한다. 
    - 추가될 기능에 가이드를 주고, 의도치 않은 장애 발생 위험을 크게 줄일 수 있다. 
5. 선택사항 열어두기
    - 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 많이, 오랫동안 열어두는 것
    - 열어둬야 하는 선택사항이란? : 중요하지 않은 세부사항
    - 소프트웨어 시스템은 두가지 구성요소로 분해 
        1. 정책 : 시스템의 진정한 가치가 살아있는 곳
        2. 세부사항 : 프로그래머가 정책과 소통할 때 필요한 요소. but 정책이 가진 행위에는 조금도 영향을 미치지 않는다. 
            - ex) IO장치, DB, 웹 시스템, 서버, 프레임워크, 통신 프로토콜
    - 아키텍트의 목표 : **정책**을 가장 핵심적인 요소로 식별. **세부사항**들은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축.
        - ex) 개발 초기에 고수준의 정책은 어떤 종류의 DB를 사용하는지 신경써서는 안된다. 
          - 동작하는 고수준의 정책이 있고, 이 정책이 DB에 독립적이라면 다양한 DB후보를 두고 적용 가능성과 선능을 검토해볼 수 있다. -> 정보가 많아진다.
    - 세부사항에 신경 안쓰고 고수준의 정책을 만들 수 있다면, 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다. 
    - 뛰어난 아키텍트는 세부사항 결정이 내려지지 않은 것처럼 행동하고, 결정을 가능한 오랫동안 연기하거나 변경할 수 있는 형태로 시스템을 만든다. 
6. 장치 독립성 : 현재의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화했고ㅡ 해당 함수는 단위 레코드를 처리한다. 
7. 물리적 주소 할당 : 하드웨어 정보가 하드코딩 되어있는 사례가 있었음. 시스템에서 고수준의 정책이 디스크의 물리적 구조로부터 독립되도록 수정 -> 디스크 드라이브 구조에 대한 결정사항을 애플리케이션으로 부터 분리 

⭐좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내어 둘이 결합되지 않도록 엄격하게 분리한다. 

<br><br><br>

## 16장 독립성 
좋은 아키텍처는 아래 4가지를 지원해야한다. 
1. 유스케이스 : 시스텡의 아키텍처는 시스템의 의도를 지원해야한다.  
    - 아키텍트의 최우선 관심사는 유스케이스 
    - 아키텍처는 시스템 행위에 큰 영향을 주지 않지만, 영향력이 전부는 아니다. 좋은 아키텍처는 행위를 명확히하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것. 
    - 시스템 구조에서 유스케이스가 한눈에 보이면 개발자는 일일이 찾아 해매지 않아도 된다. 
    - 이들 요소는 클래스/함수/모듈로서 아키텍처 내에서 핵심적인 역할을 하고 자신의 기능을 분명히 하게 설명하는 이름을 가져야함.
2. 운영
    - 아키텍처가 각 컴포넌트를 적절히 격리하여 유지하고, 각 컴포넌트간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 스레드/프로세스/서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다. 
3. 개발 
    - 아키텍처는 개발환경을 지원하는데 핵심적인 역할을 수행 
    - 콘웨이의 법칙 : 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조 설계를 만들어낼 것이다. 
    - 팀이 많은 조직이라면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보하여 팀간 방해가 없도록 해야한다. -> 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 
4. 배포 
    - 좋은 아키텍처는 수십개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다. 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야한다.
    - 각 컴포넌트를 잘 분리/격리 시키고 master컴포넌트로 시스템 전체를 하나로 묶고 각 컴포넌트를 올려 구동되고 통합하게 관리해야한다. 
<br><br>

- 선택사항 열어놓기 
    - 현실에서는 모든 유스케이스 알 수 없고, 운영하는데 따르는 제약사항, 팀 구조, 배포 요구사항을 알 수 없다. 다 파악했다 해도 변하기 마련 
    - 하지만 선택사항을 열어 둠으로써, 향후 시스템 변경이 필요할 떄 유연하게 변경할 수 있도록 해야 한다. 
<br><br>

- 계층 결합 분리 
    - 모든 유스케이스를 알 수는 없지만, 기본적인 의도는 분명 알고 있다. -> SRP와 OCP를 적용하여 의도와 맥락에 따라서 다른 이유로 변경되는 것들은 분리. 동일한 이유로 변경되는 것들은 묶는다. 
      - 서로 다른 이유로 변경되는 것 : 사용자 인터페이스 & 업무 규칙(비지니스 로직) -> 둘은 아무 관련이 없다. 독립적으로 유지할 것 
      - 서로 동일한 이유로 변경되는 것 : 업무 규칙 & 애플리케이션 자체 -> 필드 유효성 검사는 애플리케이션 자체와 관련있음 
    - DB, 쿼리 언어, 스키마... 다 기술적인 세부사항. 업무규칙이나 UI와 전혀 상관이 없음 -> 독립적으로 변경해야함. 

<br><br>
**아키텍처가 지원해야하는 4가지의 분리**

1. 유스케이스 결합 분리 
    - 유스케이스 자체가 다른 이유로 변경되는 것들 (ex. 주문 입력과 주문 삭제는 변경이유가 다름) 
    - 얇은 수직적인 유스케이스로 시스템을 분하랗면 새로운 유스케이스를 추가하거나 수정하더라도 기존 유스케이스에 영향주는 일은 거의 없을 것이다. 

- 결합 분리 모드 
    - ![image](https://github.com/nahyunLee/clean-architecture-for-commit/assets/52403454/fec06500-5756-49bf-8c43-cb63c90ce5ac)
    - 운영 관점에서의 결합 분리 
      - 유스케이스가 관점 기준으로 분리되었다면, 높은 처리량을 보장해야하는 유스케이스와 낮은 처리량으로 충분한 유스케이스가 분리되어있을 호가률이 높다. 
      - 운영측면에서 이점을 가져가려면 적절한 모드를 사용해야한다. ex) 분리된 컴포넌트를 서로 다른 서버에서 실행해야하는 상황 -> 이들 컴포넌트가 단일 프로세서의 동일한 주소 공간에 함꼐 존재하면 안된다. 분리된 컴포넌트라면 반드시 독립적으로 서비스 되어야 하고 네트워크를 통해 통신해야한다. 
      - 많은 아키텍트가 이런 컴포넌트를 Servie/Micro Service라고 하는데 약간 애매모호하니 서비스 지향 아키텍처라고 부르자 
      - 마이크로 서비스, SOA가 최고라고 하는 것이 아니라 , 때때로 컴포넌트를 서비스 수준까지도 분리해야한다는 것 
  
  
  <br><br>

 2. 개발 독립성 
    - 컴포넌트가 완전히 분리되면 팀 사이의 간섭이 줄어든다. 
    - 유스케이스 결합이 분리되는 한 시스템 아키텍처는 그 팀의 구조를 뒷바침해줄 것이다. 

<br><br>

3. 배포 독립성
    - 유스케이스 결합이 분리되면 배포에도 고도의 유연성이 생긴다. 
    - 제대로 분리했다면 운영 중에도 유스케이스를 교체할 수 있다. 
    - 새로운 유스케이스를 추가하는 일은 나머지를 그대로 둔 채 새로운 jar파일이나 서비스 몇 개를 추가하는 정도로 단순한 일이 된다.
<br><br>


- 중복 
  - 소프트웨어에서는 중복이 일반적으로 나쁘다
  - 중복의 종류 
      - 진짜 중복 : 인스턴스가 변경되면 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야함
      - 거짓된/우발적인 중복 : 서로 다른 속도와 이유로 변경된다면 두 코드는 중복이 아니다. 
    - 유스케이스가 비슷해서 코드를 통합해서(중복을 줄이고자) 작성하고 싶지만, 시간이 지마고 다른 기능을 가질 확률이 높다. 그렇다면 나중에 떼어내는데 또 고생을 해야한다. 
    - 비슷한 알고리즘. 화면구조. 데이터베이스 쿼리와 스키마를 가진다고 해서 진짜 중복이라고 속지말 것.
    - 진짜 중복인지 가짜 중복인지 확인 필요 
    - DB레코드의 구조가 특정 화면의 데이터 구조와 상당히 비슷하다는 점을 발견했다. 이 때 레코드와 동일한 뷰 모델을 만들어서 각 항목을 복사하는게 아니라 레코드를 그대로 UI까지 전달하고 싶다는 유혹을 받을 수도 있다. -> 우발적 중복이다. 뷰 모델을 만드는 일은 큰 노력이 들지 않을 뿐만이 아니라 계층간 결합을 적절하게 분리하여 유지하는 데도 도움이 될 것이다. 
<br><br>

- 결합분리 모드 
  - 계층과 유스케이스의 결합을 분리하는 방법
  1. 소스코드 단위
      - 소스코드 모듈 사이의 의존성 제어 
      - 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있는데 (루비 Gem) 이 모드에서는 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 때 간단한 함수 호출
      - 컴퓨터 메모리에는 하나의 실행파일만 로드 -> 모노리틱 구조 
  2. 바이너리코드(배포) 수준 분리 모드
      - 한 소스코드가 변하더라도 다른 모듈을 재빌드 하거나 재배포 하도록 할 수 있다. 
      - 컴포넌트가 같은 주소 공간에 상주, 단순 함수 호출을 통해 통신 
      - 어떤 컴포넌트는 다른 프로세스에 상주하고, 프로세스간 통신.소켓,공유 메모리를 통해 통신 가능 
  3. 실행단위(서비스)수준 분리 모드 
      - 순전히 네트워크 패킷을 통해서만 통신하도록
      - 마이크로 서비스 

  - 프로젝트 진행 단계에 따라서 좋은 방법이 다름 
  - 서비스 수준 분리 모드가 현재 가장 인기 있고 단순한 해결책. 하지만 비용이 많이 들고 아무리 micro하다고 하더ㄹ도 충분한 작은 단위까지 분리될 가능성은 거의 없음.
  - 컴포넌트가 서비스화될 가능성이 있다면 컴포넌트 결합을 분리하되 서비스가 되기 직전 멈추는 방식을 선호.  -> 컴포넌트들을 가능한 오랫동안 동일 주소 공간에 남겨둔다 -> 서비스에 대한 선택권을 열어둘 수 있음 -> 컴포넌트가 코드 수준에서 분리 
  - 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 독립적인 서비스나 마이크로 서비스 수준까지 성장할 수 있도록 만들어져야한다. 
  - 또한 나중에 상황이 바뀌었을 때 다시 모노리틱 구조로 되돌릴 수도 있어야 한다. 
  - 이러한 변경으로부터 소스코드를 보호해야한다. 
<br><br>


## 17장 경계: 선긋기
- 아키텍처는 경계를 만들어 요소들을 분리하고 서로 알지 못하게 하는 기술 
- 아키텍트의 목표는 시스템을 만들고 유지하는데 드는 인적자원을 최소화하는 것. 결합이 생기면 인적 자원의 효율이 떨어진다.
- 요구사항(유스케이스)와 전혀 관련 없는 결정은 이른 결정. 
- 선을 언제? 잘? 긋는 방법
  - 관련 있는 것과 없는 것 사이에 선을 긋는다. ex)DB과 GUI사이에 선이 있어야 한다. 
  - <img width="402" alt="image" src="https://github.com/nahyunLee/clean-architecture-for-commit/assets/52403454/627711ad-40ed-4e15-ba3c-ffd2e7cb4b52">
  
     - 인터페이스는 상징적이다. 
     - BusinessRules는 DatabaseInterface를 사용하여 데이터를 로드하고 저장.
     - DatebaseAccess는 DatabaseInterface를 구현하며 Database를 실제로 조작하는 일을 맡는다.
     - DatabaseAccess가 존재하는 사실을 알고 있는 클래스는 없다. 

  - <img width="425" alt="image" src="https://github.com/nahyunLee/clean-architecture-for-commit/assets/52403454/a7f13b54-df4a-42c4-b6dd-512aedce44f5">
 
      - 컴포넌트화 
      - Database는 BusinessRules에 대해 알고 있다. 반대는 알지 못한다. 
      - DatabaseInterface는 BusinessRulse컴포넌트
      - BusinessRules에게 있어 DataBase는 문제가 되지는 않지만 Database는 BusinessRules없이는 존재할 수 없다. 
      - 어떤 종류의 DB도 사용 가능하다. 
      - 업무 규칙을 먼저 작성하고 테스트하는데 더 집중할 수 있다.
<br><br>

- 입력과 출력은?
  - 입출력은 중요하지 않다. 중요한 것은 업무 규칙이다. 
  - 우리는 시스템의 행위를 입출력이 지닌 행위적 측면에서 생각하는 경향이 많지만 모델은 인터페이스(화면, 마우스, 음향)를 전혀 필요로하지 않는다. 
  - <img width="484" alt="image" src="https://github.com/nahyunLee/clean-architecture-for-commit/assets/52403454/df5ae291-0904-440c-a08b-ca044200ff0e">
  
    - GUI가 BusinessRules를 신경쓴다. 따라서 GUI는 다른 종류의 인터페이스로 얼마든지 교체가 된다.
<br><br>


- 플러그인 아키텍처
  - 선택적이거나 다양한 형태로 구현될 수 있는 컴포넌트와 핵심적인 업무 규칙은 분리되어있고 독립적이어야 한다. 
  - <img width="492" alt="image" src="https://github.com/nahyunLee/clean-architecture-for-commit/assets/52403454/cb2b779f-5071-48c8-ac47-dc0ffcdfc2bc">


    - 플러그인 형태로 연결. 어떤 기술로도 대체가 가능 
    - 교체가 되더라도 UI간 통신 일부는 재작업을 해야하지만, 최소한의 작업범위로 설계 가능
    - 변경이 전파될 수 없는 방화벽 생성 가능. GUI에서 발생한 변경은 업무 규칙에 영향을 미칠 수 없다. 
<br><br>

⭐️저수분의 세부사항에서 고수준의 추상화를 향하도록 배치하자 

