# 3장 패러다임 개요

### 구조적 프로그래밍

- 구조적 프로그래밍은 최초로 적용된 패러다임.
- 제어흐름의 직접적인 전환에 대해 규칙을 부과함.

### 객체 지향 프로그래밍

- 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장함.
- 제어흐름의 간접적인 전환에 대해 규칙을 부과함.

### 함수형 프로그래밍

- 람다 계산법 발명에 영향을 받아 함수형 프로그래밍이 만들어짐.
- 할당문에 대해 규칙을 부과함.

### 생각할 거리

- 위의 세 가지 프로그래밍 패러다임은 프로그래머에게서 권한을 박탈하고 새로운 권한을 부여하지 않음.
- 각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과함.
    - 즉, 패러다임은 무엇을 해야 할지를 말하기 보다는 무엇을 해서는 안 되는지를 말해줌.

### 결론

- 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용하고, 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과하며, 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용함.
- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사인 함수, 컴포넌트 분리, 데이터 관리가 어떻게 서로 연관되는지 주목해야함.

<br>

# 4장 구조적 프로그래밍

### 증명

- 데이크스트라는 프로그래밍 원리나 과학을 증명한 사람이 아무도 없으므로 자신의 직업이 진지하게 받아들여지지 않을까봐 염려하여 원리를 발견하려고 함.
- 데이크스트라는 **증명**이라는 수학적 원리를 적용하여 프로그래머가 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 코드가 올바르다는 사실을 스스로 증명할 수 있도록 함.
- 데이크스트라는 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견함.
    - 단순한 열거법을 이용해 순차 구문이 올바름을 입증할 수 있다는 사실을 보여주었고, 이 기법에서는 각 순차 구문의 입력을 순차 구문의 출력까지 수학적으로 추적함.
    - 분기, 반복 등
- 증명으로 해냄으로써 프로그램에서도 정리에 대한 유클리드 계층구조를 만들 수 있을 거라는 생각이 실제로 이루질 듯 함.

### 해로운 성명서

- goto 문의 해로움이라는 글로 논쟁이 생김.
- 컴퓨터 언어가 진화하면서 goto 문장이 밀려나면서 거의 사라짐.
    - 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문.
- goto 키워드를 여전히 지원하는 언어에서도 goto문의 목적지 범위를 현재 함수 안으로 한정시키는 편임.

### 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 의미함.
    - 즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있음.
    - 이들 각 기능은 다시 저순준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있음.
- 이를 토대로 구조적 분석, 구조적 설계가 인기를 끌었고, 이들 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입중할 수 있는 아주 작은 기능들로 세분화할 수 있음.

### 과학이 구출하다

- 과학은 근본적으로 수학과는 다르게 과학 이론과 법칙은 그 올바름을 절대 증명할 수 없음.
    - 즉, 과학적 방법은 반증은 가능하지만 증명은 불가능함.
- 결론적으로 수학은 증명 간으한 서술이 참임을 입증하는 원리라고 볼 수 있고, 반면 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있음.

### 테스트

- 데이크스트라는 ‘테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다’고 말함.
    - 다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고는 증명할 수 없음.
        - 테스트에 충분한 노력을 들였다면 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부임.
    - 소프트웨어의 개발이 수학적인 구조를 다루는 듯 보이더라도, 소프트웨어 개발은 수학적인 시도가 아니라 오히려 과학과 같다는 의미.
        - 최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문.

### 결론

- 구조적 프로그래밍이 가치 있는 이유
    - 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문.
    - 흔히 현대적 언어가 아무런 제약 없는 goto 문장을 지원하지 않음.
    - 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여김.
- 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 반증 가능성에 의해 주도됨.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야 하며, 이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 반아들여 활용해야 함.

<br>

# 5장 객체 지향 프로그래밍

- 좋은 아키텍처를 만드는 일은 객체 지향 OO 설계 원칙을 이해하고 응용하는 데서 출발함.
    - OO에 들어갈 말로 적절하지 않은 것
        - 데이터와 함수의 조합
        - 실제 세계를 모델링하는 새로운 방법
    - OO의 본질을 설명하기 위해 캡슐화, 상속, 다형성 이 세 가지 개념을 적절하게 조합한 것이거나, 또는 OO 언어는 최소한 세 가지 요소를 반드시 지원해야 함.

### 캡슐화

- OO을 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문.
    - 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있음.
    - 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출됨.
    - 이 개념들이 실제 OO 언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현됨.
- OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 위회해서 사용하지 않을 거라는 믿음을 기반으로 함.
    - 하지만 OO를 제공한다고 주장한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없음.

### 상속

- OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 OO 언어가 확실히 제공함.
- 상속 : 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 것.
- OO 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되어 왔지만, 사실상 상속만큼 편리한 방식은 아니었고, 이 기법을 이용해 다중 상속을 구현하는 것조차 훨씬 어려운 일이었음.
    - 따라서 OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고 볼 수 있음.

### 다형성

- OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해줌.
- 함수의 포인터는 위험하다는 문제가 있어 함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 방식에도 문제가 있다고 볼 수 있음.
    - 이러한 기법은 프로그래머가 특정 관례를 수동으로 따르는 방식이며, 이들 포인터를 통해 모든 함수를 호출하는 관례를 지켜야 한다는 점도 기억해야 함.
    - OO 언어는 이러한 관례를 없애주며, 실수할 위험이 없음.
    - OO 언어를 사용하면 다형성은 대수롭지 않은 일이 됨.
        - 이러한 이유로 OO는 제어흐륾을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있음.
- 다형성이 가진 힘
    - 새로운 입출력 장치가 생긴다고 해도 프로그램에서의 변경은 필요하지 않음.

- 의존성 역전
    - 전형적인 호출 트리의 경우 main 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며, 중간 수준 함수는 다시 저수준 함수를 호출함.
    - 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정됨.
    - OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 의미임.
        - OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 권한을 가짐.
    - 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포함. ⇒ **배포 독립성**
    - 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발 가능. ⇒ **개발 독립성**
    - OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력임.
        - OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있음.
